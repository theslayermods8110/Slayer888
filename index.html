<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Editor de V√≠deo Definitivo (Anti-Lag) - Mejorado</title>
<style>
  :root { font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial; }
  body { margin: 0; background: #0b0b0f; color: #e6e6e9; display: flex; gap: 18px; padding: 14px; box-sizing: border-box; min-height: 100vh; }
  .col { display: flex; flex-direction: column; gap: 10px; }
  .controls { width: 360px; min-width: 240px; max-height: calc(100vh - 28px); overflow: auto; padding: 14px; background: linear-gradient(180deg, #0f1220, #0b0b12); border-radius: 12px; box-shadow: 0 6px 30px rgba(0, 0, 0, 0.6); }
  .viewer { flex: 1; display: flex; flex-direction: column; gap: 10px; min-width: 0; }
  label { font-size: 13px; color: #bfc4d6; margin-top: 8px; }
  input[type=range] { width: 100%; cursor: pointer; }
  .row { display: flex; gap: 8px; align-items: center; }
  button, select, input[type=file] { transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease; }
  button { padding: 8px 12px; border-radius: 8px; border: none; background: #1f2937; color: #fff; cursor: pointer; }
  button:hover { background: #374151; box-shadow: 0 0 15px rgba(30, 41, 59, 0.7); }
  button:disabled { background: #374151; color: #9ca3af; cursor: not-allowed; }
  button.primary { background: #0ea5a4; }
  button.primary:hover { background: #14b8b6; box-shadow: 0 0 15px rgba(13, 148, 136, 0.7); }
  button.danger { background: #9f1239; }
  button.danger:hover { background: #e11d48; box-shadow: 0 0 15px rgba(159, 18, 57, 0.7); }
  select, input[type=file] { background: #0b0b12; color: #e6e6e9; padding: 8px; border-radius: 8px; border: 1px solid #1f2937; width:100%; box-sizing: border-box; }
  small { color: #9aa2b2; }
  .status { font-size: 13px; color: #99a3b6; word-break: break-word; min-height:1.2em; }
  .canvas-wrap { flex: 1; display: flex; flex-direction: column; gap: 8px; }
  canvas#glcanvas { background: #000; display: block; border-radius: 8px; width: 100%; height: calc(100vh - 220px); max-height: calc(100vh - 120px); object-fit: contain; image-rendering: pixelated; }
  .hint { font-size: 12px; color: #8892a6; }
  .seek { width: 100%; display: flex; gap: 8px; align-items: center; }
  .time { font-size: 12px; color: #9aa2b2; min-width: 68px; text-align: right; }
  progress { width: 100%; height: 4px; display: none; }
  @media (max-width: 900px) { body { flex-direction: column; padding: 10px; } .controls { width: 100%; max-height: none; } canvas#glcanvas { height: 60vh; max-height: none; } }
</style>
</head>
<body>
  <div class="col controls" id="controlsContainer">
    <h2>Editor Definitivo üíñ</h2>
    <label>Archivo de v√≠deo (local)</label>
    <input id="videoFile" type="file" accept="video/*" />
    <label>Resoluci√≥n de salida</label>
    <select id="outRes">
      <option value="1280x720">720p HD</option>
      <option value="1920x1080" selected>1080p Full HD</option>
      <option value="3840x2160">4K UHD</option>
      <option value="7680x4320">8K UHD</option>
    </select>
    <label>Filtro de Pel√≠cula</label>
    <select id="movieFilter">
        <option value="0" selected>Ninguno</option>
        <option value="1">Cinem√°tico (Naranja y Turquesa)</option>
        <option value="2">Vintage (Sepia Cl√°sico)</option>
        <option value="3">Noir (Blanco y Negro)</option>
        <option value="4">Ensue√±o (Brillo Suave)</option>
        <option value="5">Tecnicolor (Vibrante)</option>
    </select>
    <label>Calidad de escalado</label>
    <select id="scaleMode">
      <option value="nearest">Nearest (M√°xima Velocidad)</option>
      <option value="bilinear" selected>Bilinear (Balanceado)</option>
      <option value="bicubic">Bicubic (M√°xima Calidad)</option>
    </select>
     <label>FPS (Salida y Preview)</label>
    <select id="previewFps">
      <option>24</option><option>30</option><option selected>60</option><option>120</option><option>240</option>
    </select>
    <label>Filtros Manuales (Acelerados por GPU)</label>
    <div>
      <div class="row"><label style="flex:1">Nitidez</label><input id="sharpen" type="range" min="0" max="2" step="0.01" value="0" /></div>
      <div class="row"><label style="flex:1">Contraste</label><input id="contrast" type="range" min="0" max="2" step="0.01" value="1.0" /></div>
      <div class="row"><label style="flex:1">Saturaci√≥n</label><input id="saturation" type="range" min="0" max="2" step="0.01" value="1.0" /></div>
      <div class="row"><label style="flex:1">Brillo</label><input id="brightness" type="range" min="0" max="2" step="0.01" value="1.0" /></div>
      <div class="row"><label style="flex:1">Red. Ruido</label><input id="denoise" type="range" min="0" max="6" step="0.1" value="0" /></div>
    </div>
    <label>Controles</label>
    <div class="row">
      <button id="playBtn">‚ñ∂ Reproducir</button>
      <button id="pauseBtn">‚è∏ Pausa</button>
      <button id="renderDownloadBtn" class="primary" disabled>‚¨áÔ∏è Renderizar y Descargar MP4</button>
      <button id="cancelRenderBtn" class="danger" style="display:none;">‚ùå Cancelar</button>
    </div>
    <div style="margin-top:8px"><div class="status" id="status">Estado: inactivo</div></div>
    <progress id="progressBar" value="0" max="100"></progress>
    <hr/>
    <small class="hint">Toda la carga de video se procesa en segundo plano para una interfaz 100% fluida.</small>
  </div>
  <div class="viewer">
    <div class="canvas-wrap">
      <canvas id="glcanvas"></canvas>
      <div class="seek">
        <input id="seekBar" type="range" min="0" step="0.01" value="0" style="flex:1"/>
        <div class="time"><span id="curTime">0:00</span> / <span id="durTime">0:00</span></div>
      </div>
    </div>
  </div>

<script>
const get = (id) => document.getElementById(id);

const canvas = get('glcanvas');
const fileInput = get('videoFile');
const status = get('status');
const outRes = get('outRes');
const playBtn = get('playBtn');
const pauseBtn = get('pauseBtn');
const renderDownloadBtn = get('renderDownloadBtn');
const cancelRenderBtn = get('cancelRenderBtn');
const previewFps = get('previewFps');
const scaleMode = get('scaleMode');
const seekBar = get('seekBar');
const curTime = get('curTime');
const durTime = get('durTime');
const controlsContainer = get('controlsContainer');
const progressBar = get('progressBar');
const movieFilter = get('movieFilter');


let worker = null;
let video = null; 
let isRenderingCancelled = false;

function getAppSettings() {
    const filters = {};
    ['sharpen', 'contrast', 'saturation', 'brightness', 'denoise'].forEach(id => {
        filters[id] = parseFloat(get(id).value);
    });
    const [width, height] = outRes.value.split('x').map(v => parseInt(v, 10));
    return {
        width,
        height,
        fps: parseInt(previewFps.value, 10),
        scaleMode: scaleMode.value,
        movieFilter: parseInt(movieFilter.value, 10),
        filters
    };
}

function setControlsEnabled(enabled, isRendering = false) {
    controlsContainer.querySelectorAll('input, select').forEach(el => {
        el.disabled = !enabled;
    });
    playBtn.disabled = !enabled;
    pauseBtn.disabled = !enabled;
    renderDownloadBtn.disabled = !enabled || !fileInput.files.length;

    renderDownloadBtn.style.display = isRendering ? 'none' : 'inline-block';
    cancelRenderBtn.style.display = isRendering ? 'inline-block' : 'none';
    progressBar.style.display = isRendering ? 'block' : 'none';
}

function formatTime(s) {
    if (!s || !isFinite(s)) return '0:00';
    const mm = Math.floor(s / 60);
    const ss = Math.floor(s % 60).toString().padStart(2, '0');
    return `${mm}:${ss}`;
}

function initializeWorker() {
    const workerCode = `
        const VS=\`attribute vec2 aPos;attribute vec2 aTex;varying vec2 vTex;void main(){vTex=aTex;gl_Position=vec4(aPos,0.0,1.0);}\`;
        const FS=\`precision mediump float;varying vec2 vTex;uniform sampler2D uTex;uniform vec2 uTexSize;uniform float uSharpen;uniform float uContrast;uniform float uSaturation;uniform float uBrightness;uniform float uDenoise;uniform int uMovieFilter;vec3 rgb2hsv(vec3 c){vec4 K=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);float e=1.0e-10;return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)),d/(q.x+e),q.x);}vec3 hsv2rgb(vec3 c){vec3 rgb=clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);return c.z*mix(vec3(1.0),rgb,c.y);}float luma(vec3 color){return dot(color,vec3(0.299,0.587,0.114));}void main(){vec4 col=texture2D(uTex,vTex);if(uDenoise>0.01){vec2 px=1.0/uTexSize;vec4 sum=vec4(0.0);for(int y=-1;y<=1;y++){for(int x=-1;x<=1;x++){sum+=texture2D(uTex,vTex+vec2(float(x),float(y))*px);}}col=mix(col,sum/9.0,clamp(uDenoise/6.0,0.0,1.0));}if(uSharpen>0.001){vec2 px=1.0/uTexSize;vec4 blur=(texture2D(uTex,vTex-px)+texture2D(uTex,vTex+px)+texture2D(uTex,vTex-vec2(px.y,px.x))+texture2D(uTex,vTex+vec2(px.y,px.x)))/4.0;vec4 mask=col-blur;col+=mask*uSharpen;}vec3 c=col.rgb;c*=uBrightness;c=((c-0.5)*uContrast)+0.5;vec3 hsv=rgb2hsv(c);hsv.y*=uSaturation;c=hsv2rgb(hsv);if(uMovieFilter>0){if(uMovieFilter==1){vec3 orange=vec3(1.0,0.6,0.2);vec3 teal=vec3(0.1,0.5,0.6);float l=luma(c);c=mix(c,orange,clamp(l*1.2-0.2,0.0,0.7));c=mix(c,teal,clamp(1.0-l*1.5,0.0,0.5));}else if(uMovieFilter==2){vec3 sepia=vec3(dot(c,vec3(0.393,0.769,0.189)),dot(c,vec3(0.349,0.686,0.168)),dot(c,vec3(0.272,0.534,0.131)));c=sepia;float dist=distance(vTex,vec2(0.5));c*=smoothstep(0.8,0.2,dist);}else if(uMovieFilter==3){float gray=luma(c);c=vec3(gray);c=((c-0.5)*1.5)+0.5;}else if(uMovieFilter==4){vec3 bloom=texture2D(uTex,vTex).rgb;c=mix(c,bloom,0.3);c=pow(c,vec3(0.8));}else if(uMovieFilter==5){vec3 hsv_tech=rgb2hsv(c);hsv_tech.y*=1.5;c=hsv2rgb(hsv_tech);}}gl_FragColor=vec4(clamp(c,0.0,1.0),col.a);}\`;

        let gl, program, buffers={}, uniforms={}, settings, renderCanvas, renderCtx, mediaRecorder, recordedChunks, fileExtension;

        function initGL(canvas) {
            gl = canvas.getContext('webgl2', { antialias: true, powerPreference: 'high-performance' }) || canvas.getContext('webgl', { antialias: false, powerPreference: 'low-power' });
            
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, VS);
            gl.compileShader(vs);

            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, FS);
            gl.compileShader(fs);

            program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            gl.useProgram(program);

            const quad = new Float32Array([-1,-1,0,0,1,-1,1,0,-1,1,0,1,1,1,1,1]);
            buffers.vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.vbo);
            gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
            const aPos = gl.getAttribLocation(program, 'aPos');
            const aTex = gl.getAttribLocation(program, 'aTex');
            gl.enableVertexAttribArray(aPos);
            gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 16, 0);
            gl.enableVertexAttribArray(aTex);
            gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 16, 8);
            
            buffers.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, buffers.texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
             
            uniforms = {
                uTex: gl.getUniformLocation(program, 'uTex'), uTexSize: gl.getUniformLocation(program, 'uTexSize'),
                uSharpen: gl.getUniformLocation(program, 'uSharpen'), uContrast: gl.getUniformLocation(program, 'uContrast'),
                uSaturation: gl.getUniformLocation(program, 'uSaturation'), uBrightness: gl.getUniformLocation(program, 'uBrightness'),
                uDenoise: gl.getUniformLocation(program, 'uDenoise'),
                uMovieFilter: gl.getUniformLocation(program, 'uMovieFilter'),
            };
        }
        
        function drawFrame(frame) {
            if (!gl || !frame) return;
            
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, buffers.texture);

            const filter = settings.scaleMode === 'nearest' ? gl.NEAREST : gl.LINEAR;
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter);

            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, frame);
            
            for(const key in settings.filters) {
                gl.uniform1f(uniforms['u'+key.charAt(0).toUpperCase() + key.slice(1)], settings.filters[key]);
            }
            gl.uniform1i(uniforms.uMovieFilter, settings.movieFilter);
            gl.uniform2f(uniforms.uTexSize, frame.width, frame.height);
            gl.uniform1i(uniforms.uTex, 0);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        self.onmessage = (e) => {
            const { type, payload } = e.data;
            switch(type) {
                case 'init':
                    settings = payload.settings;
                    initGL(payload.canvas);
                    gl.canvas.width = payload.frameWidth;
                    gl.canvas.height = payload.frameHeight;
                    break;
                case 'updateSettings':
                    settings = payload;
                    break;
                case 'newFrame':
                    gl.canvas.width = payload.frame.width;
                    gl.canvas.height = payload.frame.height;
                    drawFrame(payload.frame);
                    payload.frame.close();
                    break;
                case 'startRender':
                     settings = payload;
                     renderCanvas = new OffscreenCanvas(settings.width, settings.height);
                     renderCtx = renderCanvas.getContext('2d');
                     // CORRECCI√ìN: Voltear el canvas de renderizado para que coincida con la salida de WebGL
                     renderCtx.translate(0, settings.height);
                     renderCtx.scale(1, -1);
                     
                     const stream = renderCanvas.captureStream(settings.fps);
                     
                     const mp4Mime = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';
                     const webmMiMe = 'video/webm;codecs=vp9,opus';
                     let mimeType = webmMiMe;
                     fileExtension = 'webm';

                     if (MediaRecorder.isTypeSupported(mp4Mime)) {
                        mimeType = mp4Mime;
                        fileExtension = 'mp4';
                     } else {
                        console.warn("MP4 no es soportado, usando WebM como alternativa.");
                     }

                     try {
                        mediaRecorder = new MediaRecorder(stream, { mimeType, videoBitsPerSecond: 25000000 });
                     } catch(err) {
                        self.postMessage({ type: 'error', message: 'MediaRecorder no es compatible o el c√≥dec necesario no est√° disponible.' });
                        return;
                     }
                     recordedChunks = [];
                     mediaRecorder.ondataavailable = event => { if (event.data.size > 0) recordedChunks.push(event.data); };
                     mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: mimeType });
                        self.postMessage({ type: 'downloadReady', payload: { blob, fileExtension } });
                     };
                     mediaRecorder.start();
                     break;
                case 'renderFrame':
                    gl.canvas.width = payload.frame.width;
                    gl.canvas.height = payload.frame.height;
                    drawFrame(payload.frame);
                    
                    renderCtx.drawImage(gl.canvas, 0, 0, settings.width, settings.height);
                    payload.frame.close();
                    break;
                case 'finishRender':
                     if (mediaRecorder && mediaRecorder.state === 'recording') {
                         mediaRecorder.stop();
                     }
                     break;
            }
        };
    `;
    const blob = new Blob([workerCode], { type: 'application/javascript' });
    worker = new Worker(URL.createObjectURL(blob));

    worker.onmessage = (e) => {
        const { type, payload, message } = e.data;
        switch (type) {
            case 'downloadReady':
                const url = URL.createObjectURL(payload.blob);
                const a = document.createElement('a');
                a.href = url;
                const ts = new Date().toISOString().slice(0, 19).replace(/[-:T]/g, '');
                a.download = `video_editado_${ts}.${payload.fileExtension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                status.textContent = 'Render completado. ¬°Descargando!';
                setControlsEnabled(true);
                break;
            case 'error':
                 alert(message);
                 status.textContent = 'Error en render.';
                 setControlsEnabled(true, false);
                 break;
        }
    };
}

function renderLoop() {
    if (!video || video.paused || video.ended) {
        return;
    }
    createImageBitmap(video).then(frame => {
        worker.postMessage({ type: 'newFrame', payload: { frame } }, [frame]);
    });
    
    if (!seekBar.matches(':active')) {
      seekBar.value = video.currentTime;
      curTime.textContent = formatTime(video.currentTime);
    }
    
    video.requestVideoFrameCallback(renderLoop);
}

fileInput.addEventListener('change', () => {
    const file = fileInput.files[0];
    if (!file) return;

    if (worker) {
        worker.terminate();
    }
    initializeWorker();

    const videoURL = URL.createObjectURL(file);
    if (!video) {
      video = document.createElement('video');
      video.muted = true;
      video.crossOrigin = "anonymous";
      video.style.display = 'none';
      document.body.appendChild(video);
    }
    video.src = videoURL;
    video.load();

    video.onloadedmetadata = () => {
      if (!HTMLVideoElement.prototype.requestVideoFrameCallback) {
        alert('Tu navegador es demasiado antiguo o no soporta APIs de video modernas. El rendimiento ser√° bajo.');
      }
      const offscreen = canvas.transferControlToOffscreen();
      const settings = getAppSettings();
      worker.postMessage({ type: 'init', payload: { canvas: offscreen, settings, frameWidth: video.videoWidth, frameHeight: video.videoHeight } }, [offscreen]);
      
      setControlsEnabled(true);
      status.textContent = `Video cargado: ${video.videoWidth}x${video.videoHeight}`;

      seekBar.max = video.duration;
      durTime.textContent = formatTime(video.duration);
    };
    
    video.onerror = () => {
        alert("Error al cargar el archivo de video. Puede estar corrupto o en un formato no compatible.");
        status.textContent = "Error de carga.";
        setControlsEnabled(false);
    };
});

playBtn.addEventListener('click', () => {
  if(video) {
    video.play();
    video.requestVideoFrameCallback(renderLoop);
  }
});
pauseBtn.addEventListener('click', () => {
  if(video) {
    video.pause();
  }
});

seekBar.addEventListener('input', () => {
    curTime.textContent = formatTime(parseFloat(seekBar.value));
});
seekBar.addEventListener('change', () => {
    if(video) {
      video.currentTime = parseFloat(seekBar.value);
      if (video.paused) {
          video.onseeked = () => {
            createImageBitmap(video).then(frame => {
              worker.postMessage({ type: 'newFrame', payload: { frame } }, [frame]);
            });
            video.onseeked = null;
          }
      }
    }
});

async function startFileRender() {
    if (!worker || !video) return;

    setControlsEnabled(false, true);
    isRenderingCancelled = false;
    progressBar.value = 0;
    
    const settings = getAppSettings();
    worker.postMessage({ type: 'startRender', payload: settings });

    status.textContent = 'Iniciando render...';
    
    const totalFrames = Math.floor(video.duration * settings.fps);
    video.pause();
    video.currentTime = 0;
    
    // Peque√±a espera para asegurar que el currentTime se ha actualizado
    await new Promise(res => setTimeout(res, 50));

    for (let i = 0; i <= totalFrames; i++) {
        if (isRenderingCancelled) {
            status.textContent = 'Render cancelado.';
            worker.postMessage({ type: 'finishRender' });
            setControlsEnabled(true);
            return;
        }

        const time = i / settings.fps;
        if (time > video.duration) break;

        video.currentTime = time;
        await new Promise(res => video.addEventListener('seeked', res, { once: true }));
        
        const frame = await createImageBitmap(video);
        worker.postMessage({ type: 'renderFrame', payload: { frame } }, [frame]);

        const progress = Math.round((i / totalFrames) * 100);
        status.textContent = `Renderizando... ${progress}%`;
        progressBar.value = progress;
    }

    worker.postMessage({ type: 'finishRender' });
}


renderDownloadBtn.addEventListener('click', startFileRender);
cancelRenderBtn.addEventListener('click', () => {
    isRenderingCancelled = true;
});

// Unificar todos los listeners
const allControls = ['outRes', 'previewFps', 'scaleMode', 'sharpen', 'contrast', 'saturation', 'brightness', 'denoise', 'movieFilter'];
allControls.forEach(id => {
    get(id).addEventListener('change', () => {
        if (worker) {
          const settings = getAppSettings();
          worker.postMessage({ type: 'updateSettings', payload: settings });
          if (video && video.paused) {
              video.onseeked = () => {
                createImageBitmap(video).then(frame => {
                  worker.postMessage({ type: 'newFrame', payload: { frame } }, [frame]);
                });
                video.onseeked = null;
              }
              // Forzar un re-seek para que se actualice el frame
              video.currentTime = video.currentTime;
          }
        }
    });
});

window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && document.activeElement.tagName !== 'BUTTON' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'SELECT') {
        e.preventDefault();
        if(video) {
          if(video.paused) {
            playBtn.click();
          } else {
            pauseBtn.click();
          }
        }
    }
});

</script>
</body>
</html>
